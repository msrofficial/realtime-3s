<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Particle Playground</title>
    <style>
        :root {
            --bg-color: #0d0d0d;
            --panel-bg: rgba(20, 20, 20, 0.85);
            --accent: #00e5ff;
            --text: #ffffff;
            --font: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--font);
            user-select: none;
        }

        /* Canvas & Video */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #input-video {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border-radius: 8px;
            transform: scaleX(-1); /* Mirror */
            opacity: 0.5;
            z-index: 2;
            pointer-events: none;
            border: 2px solid var(--accent);
            display: none; /* Hidden until loaded */
        }

        /* UI Overlay */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            padding: 20px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 10;
            color: var(--text);
            transition: transform 0.3s ease;
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; font-weight: 600; letter-spacing: 0.5px; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 12px; margin-bottom: 5px; opacity: 0.8; }
        
        /* Custom Inputs */
        input[type="range"] {
            width: 100%;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .shape-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .shape-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid transparent;
            color: white;
            padding: 8px 0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .shape-btn:hover { background: rgba(255,255,255,0.2); }
        .shape-btn.active { background: var(--accent); color: #000; font-weight: bold; }

        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .btn-action {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, var(--accent), #00ff9d);
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
        }

        /* Loading Overlay */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--accent);
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(0,229,255,0.3);
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .status { font-size: 12px; margin-top: 10px; opacity: 0.7; }

        /* Color Picker Reset */
        input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 4px;
            background: none;
            cursor: pointer;
        }

        /* Minimized View for Mobile */
        @media (max-width: 600px) {
            #ui-panel { width: calc(100% - 40px); bottom: 20px; top: auto; }
            #input-video { top: 10px; bottom: auto; width: 100px; height: 75px; }
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div>Initializing GPU & AI Models...</div>
        <div class="status" id="load-status">Loading Three.js...</div>
    </div>

    <video id="input-video" playsinline></video>

    <div id="canvas-container"></div>

    <div id="ui-panel">
        <div class="toggle-row">
            <h2>Particle Control</h2>
            <div style="font-size: 10px; color: var(--accent);">‚óè LIVE</div>
        </div>

        <div class="control-group">
            <label>Shape Template</label>
            <div class="shape-grid">
                <button class="shape-btn active" onclick="setShape('sphere')">Sphere</button>
                <button class="shape-btn" onclick="setShape('heart')">Heart</button>
                <button class="shape-btn" onclick="setShape('flower')">Flower</button>
                <button class="shape-btn" onclick="setShape('saturn')">Saturn</button>
                <button class="shape-btn" onclick="setShape('buddha')">Buddha</button>
                <button class="shape-btn" onclick="setShape('fireworks')">Burst</button>
            </div>
        </div>

        <div class="control-group">
            <div class="toggle-row">
                <label>Camera Control</label>
                <input type="checkbox" id="cam-toggle" checked>
            </div>
            <div class="status" id="gesture-status" style="margin-bottom: 5px;">Waiting for hands...</div>
        </div>

        <div class="control-group">
            <label>Particle Color</label>
            <input type="color" id="color-picker" value="#00e5ff">
        </div>

        <div class="control-group">
            <label>Particle Count (<span id="count-val">15000</span>)</label>
            <input type="range" id="count-slider" min="5000" max="30000" step="1000" value="15000">
        </div>

        <div class="control-group">
            <label>Motion Noise / Chaos</label>
            <input type="range" id="noise-slider" min="0" max="2" step="0.1" value="0.5">
        </div>

        <button class="btn-action" onclick="takeScreenshot()">üì∏ Capture Snapshot</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        /**
         * CONFIGURATION & STATE
         */
        const config = {
            particleCount: 15000,
            baseColor: new THREE.Color(0x00e5ff),
            particleSize: 0.15,
            gestureEnabled: true,
            mouseFallback: { x: 0, y: 0, active: false }
        };

        const state = {
            targetShape: 'sphere',
            expansion: 1.0,  // Controlled by gesture (0.1 to 3.0)
            noiseStrength: 0.5,
            handPresent: false,
            handOpenness: 0 // 0 = closed fist, 1 = open hand
        };

        let scene, camera, renderer, particles, geometry, material;
        let positionsOriginal, positionsTarget; // Arrays to store shape data
        let clock = new THREE.Clock();

        // DOM Elements
        const uiStatus = document.getElementById('load-status');
        const gestureStatus = document.getElementById('gesture-status');
        const loader = document.getElementById('loader');

        /**
         * INITIALIZATION
         */
        async function init() {
            // 1. Setup Three.js
            uiStatus.innerText = "Setting up 3D Scene...";
            initThree();

            // 2. Generate Initial Particles
            uiStatus.innerText = "Generating Particles...";
            generateParticles(config.particleCount);

            // 3. Setup MediaPipe
            uiStatus.innerText = "Starting Camera...";
            try {
                await initMediaPipe();
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            } catch (e) {
                console.error(e);
                uiStatus.innerText = "Camera denied or error. Using Mouse fallback.";
                config.gestureEnabled = false;
                document.getElementById('cam-toggle').checked = false;
                setTimeout(() => {
                    loader.style.opacity = '0';
                    setTimeout(() => loader.style.display = 'none', 500);
                }, 2000);
            }

            // 4. Start Loop
            animate();
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // Fog for depth
            scene.fog = new THREE.FogExp2(0x0d0d0d, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Perf optimization
            container.appendChild(renderer.domElement);

            // Handle Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Mouse Fallback Listeners
            document.addEventListener('mousemove', (e) => {
                if (!config.gestureEnabled) {
                    // Map Y axis to expansion, X to rotation
                    const yNorm = 1 - (e.clientY / window.innerHeight); 
                    state.expansion = 0.5 + (yNorm * 2); // 0.5 to 2.5
                    
                    config.mouseFallback.x = (e.clientX / window.innerWidth) * 2 - 1;
                    config.mouseFallback.y = -(e.clientY / window.innerHeight) * 2 + 1;
                }
            });
        }

        /**
         * PARTICLE SYSTEM ENGINE
         */
        function generateParticles(count) {
            if (particles) scene.remove(particles);

            geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(count * 3);
            const targets = new Float32Array(count * 3); // Where they want to go
            const randomness = new Float32Array(count * 3); // Per-particle noise offset

            const spherePoints = getShapePoints('sphere', count);

            for (let i = 0; i < count; i++) {
                // Init at sphere
                positions[i*3] = spherePoints[i*3];
                positions[i*3+1] = spherePoints[i*3+1];
                positions[i*3+2] = spherePoints[i*3+2];

                targets[i*3] = spherePoints[i*3];
                targets[i*3+1] = spherePoints[i*3+1];
                targets[i*3+2] = spherePoints[i*3+2];

                // Random noise vector
                randomness[i*3] = (Math.random() - 0.5);
                randomness[i*3+1] = (Math.random() - 0.5);
                randomness[i*3+2] = (Math.random() - 0.5);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('target', new THREE.BufferAttribute(targets, 3));
            geometry.setAttribute('randomness', new THREE.BufferAttribute(randomness, 3));

            // Custom Shader Material
            material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: config.baseColor },
                    time: { value: 0 },
                    expansion: { value: 1.0 },
                    pointSize: { value: config.particleSize * window.devicePixelRatio * 10.0 }
                },
                vertexShader: `
                    uniform float time;
                    uniform float expansion;
                    uniform float pointSize;
                    attribute vec3 target;
                    attribute vec3 randomness;
                    varying float vAlpha;
                    
                    // Simple mix function handled in JS, but we add noise here
                    void main() {
                        // Current position (updated via JS for morphing)
                        vec3 pos = position;
                        
                        // Apply expansion based on gesture
                        // We push particles outward from center (0,0,0)
                        vec3 dir = normalize(pos + randomness * 0.1); 
                        float dist = length(pos);
                        
                        // "Breathing" effect + Gesture Expansion
                        float breath = 1.0 + sin(time * 2.0 + dist) * 0.05;
                        vec3 finalPos = pos * (expansion * breath);

                        // Add swirling noise
                        finalPos.x += sin(time * 0.5 + pos.y) * 0.2;
                        finalPos.y += cos(time * 0.3 + pos.x) * 0.2;

                        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // Size attenuation
                        gl_PointSize = pointSize * (30.0 / -mvPosition.z);
                        
                        // Fade out edge particles
                        vAlpha = 1.0 - smoothstep(20.0, 50.0, length(finalPos));
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying float vAlpha;
                    
                    void main() {
                        // Circular particle
                        vec2 uv = gl_PointCoord.xy - 0.5;
                        float r = length(uv);
                        if (r > 0.5) discard;

                        // Soft edge
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 1.5);
                        
                        gl_FragColor = vec4(color, vAlpha * glow);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Store original target data for morphing
            positionsTarget = targets; 
        }

        /**
         * SHAPE GENERATION MATH
         */
        function getShapePoints(type, count) {
            const points = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                let x, y, z;
                const idx = i * 3;

                if (type === 'sphere' || type === 'fireworks') {
                    // Uniform sphere distribution
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = 10 * Math.cbrt(Math.random()); // Cube root for volume filling
                    
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);

                } else if (type === 'heart') {
                    // Parametric Heart
                    // x = 16sin^3(t)
                    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.random(); // volume fill
                    
                    // Basic 2D heart
                    let hx = 16 * Math.pow(Math.sin(t), 3);
                    let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    // Extrude to 3D
                    const scale = 0.5;
                    x = hx * scale * r;
                    y = hy * scale * r;
                    z = (Math.random() - 0.5) * 5 * r; // Thickness

                } else if (type === 'flower') {
                    // Polar Rose
                    const theta = Math.random() * Math.PI * 2;
                    const k = 5; // petals
                    const rBase = Math.cos(k * theta);
                    const r = 10 * rBase * Math.random();
                    
                    x = r * Math.cos(theta);
                    y = r * Math.sin(theta);
                    z = (Math.cos(r) * 2) + (Math.random()-0.5); // Curved petals

                } else if (type === 'saturn') {
                    const choice = Math.random();
                    if (choice > 0.4) {
                        // Planet body
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos((Math.random() * 2) - 1);
                        const r = 6;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    } else {
                        // Rings
                        const theta = Math.random() * Math.PI * 2;
                        const r = 9 + Math.random() * 5; // Ring radius 9 to 14
                        x = r * Math.cos(theta);
                        z = r * Math.sin(theta);
                        y = (Math.random() - 0.5) * 0.5; // Thin ring
                        
                        // Tilt the ring
                        const tilt = 0.4;
                        const tx = x;
                        const ty = y * Math.cos(tilt) - z * Math.sin(tilt);
                        const tz = y * Math.sin(tilt) + z * Math.cos(tilt);
                        x=tx; y=ty; z=tz;
                    }

                } else if (type === 'buddha') {
                    // Procedural Approximation: Stacked spheres/ovals
                    const r = Math.random();
                    
                    if (r < 0.25) { // Head
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos((Math.random() * 2) - 1);
                        const rad = 2.5;
                        x = rad * Math.sin(phi) * Math.cos(theta);
                        y = rad * Math.sin(phi) * Math.sin(theta) + 5; // Move Up
                        z = rad * Math.cos(phi);
                    } else if (r < 0.65) { // Body
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos((Math.random() * 2) - 1);
                        const rad = 4.0;
                        x = rad * Math.sin(phi) * Math.cos(theta) * 1.2; // Wider
                        y = rad * Math.sin(phi) * Math.sin(theta);
                        z = rad * Math.cos(phi) * 0.8;
              
